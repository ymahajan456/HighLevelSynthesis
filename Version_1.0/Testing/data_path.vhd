
-- ============================================================
-- File Name: data_path.vhd
-- ============================================================
-- ************************************************************
-- THIS IS A AUTO-GENERATED FILE. DO NOT EDIT THIS FILE!
-- 
-- 2.0 BUILD. GENERATED ON 2016-11-22
-- ************************************************************

LIBRARY IEEE;
USE ieee.numeric_std.all;
USE ieee.std_logic_1164.all;

ENTITY data_path IS
	GENERIC(
		data_width: INTEGER  := 16);
	PORT(
		clk: IN STD_LOGIC := '0';
		reset: IN STD_LOGIC := '0';
		T: IN STD_LOGIC_VECTOR( 0 TO 36 ) := (others => '0');
		a: IN STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
		d: IN STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
		b: IN STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
		c: IN STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
		output_0: OUT STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
		output_1: OUT STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
		output_2: OUT STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0'));
END ENTITY;

ARCHITECTURE data OF data_path is
	SIGNAL clr_REG10, ena_REG10, clk_REG10: STD_LOGIC := '0';
	SIGNAL ena_REG8, clk_REG9, clr_REG9, ena_REG9, clr_REG8: STD_LOGIC := '0';
	SIGNAL outp_REG9, inp_REG10, outp_REG10, inp_REG9: STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
	SIGNAL inp_REG7, outp_REG7, inp_REG8, outp_REG8, outp_REG6: STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
	SIGNAL clk_REG7, clr_REG7, ena_REG7, clk_REG8, ena_REG6: STD_LOGIC := '0';
	SIGNAL outp_REG4, inp_REG5, outp_REG5, inp_REG6, inp_REG4: STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
	SIGNAL clr_REG5, ena_REG5, clk_REG6, clr_REG6, clk_REG5: STD_LOGIC := '0';
	SIGNAL inp_REG2, outp_REG2, inp_REG3, outp_REG3, outp_REG1: STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
	SIGNAL ena_REG3, clk_REG4, clr_REG4, ena_REG4, clr_REG3: STD_LOGIC := '0';
	SIGNAL outp_ALU3, inp_REG0, outp_REG0, inp_REG1, in_2_ALU3: STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
	SIGNAL clk_REG2, clr_REG2, ena_REG2, clk_REG3, ena_REG1: STD_LOGIC := '0';
	SIGNAL in_1_ALU2, in_2_ALU2, outp_ALU2, in_1_ALU3, outp_ALU1: STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
	SIGNAL clr_REG0, ena_REG0, clk_REG1, clr_REG1, clk_REG0: STD_LOGIC := '0';
	SIGNAL in_2_ALU0, outp_ALU0, in_1_ALU1, in_2_ALU1, in_1_ALU0: STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
	SIGNAL sel_ALU1, sel_ALU2, sel_ALU3, sel_ALU0: STD_LOGIC_VECTOR( 0 TO 2 ) := (others => '0');
	COMPONENT ALU IS
		GENERIC(
			data_width: INTEGER  := 16);
		PORT(
			in_1: IN STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
			in_2: IN STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
			outp: OUT STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
			sel: IN STD_LOGIC_VECTOR( 0 TO 2 ) := (others => '0'));
	END COMPONENT;
	COMPONENT REG IS
		GENERIC(
			data_width: INTEGER  := 16);
		PORT(
			inp: IN STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
			outp: OUT STD_LOGIC_VECTOR( 0 TO data_width - 1) := (others => '0');
			clk: IN STD_LOGIC := '0';
			clr: IN STD_LOGIC := '0';
			ena: IN STD_LOGIC := '0');
	END COMPONENT;

begin

	ALU0: ALU
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			in_1 => in_1_ALU0,
			in_2 => in_2_ALU0,
			outp => outp_ALU0,
			sel => sel_ALU0
		);
	ALU1: ALU
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			in_1 => in_1_ALU1,
			in_2 => in_2_ALU1,
			outp => outp_ALU1,
			sel => sel_ALU1
		);
	ALU2: ALU
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			in_1 => in_1_ALU2,
			in_2 => in_2_ALU2,
			outp => outp_ALU2,
			sel => sel_ALU2
		);
	ALU3: ALU
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			in_1 => in_1_ALU3,
			in_2 => in_2_ALU3,
			outp => outp_ALU3,
			sel => sel_ALU3
		);
	REG0: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG0,
			outp => outp_REG0,
			clk => clk_REG0,
			clr => clr_REG0,
			ena => ena_REG0
		);
	REG1: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG1,
			outp => outp_REG1,
			clk => clk_REG1,
			clr => clr_REG1,
			ena => ena_REG1
		);
	REG2: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG2,
			outp => outp_REG2,
			clk => clk_REG2,
			clr => clr_REG2,
			ena => ena_REG2
		);
	REG3: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG3,
			outp => outp_REG3,
			clk => clk_REG3,
			clr => clr_REG3,
			ena => ena_REG3
		);
	REG4: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG4,
			outp => outp_REG4,
			clk => clk_REG4,
			clr => clr_REG4,
			ena => ena_REG4
		);
	REG5: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG5,
			outp => outp_REG5,
			clk => clk_REG5,
			clr => clr_REG5,
			ena => ena_REG5
		);
	REG6: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG6,
			outp => outp_REG6,
			clk => clk_REG6,
			clr => clr_REG6,
			ena => ena_REG6
		);
	REG7: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG7,
			outp => outp_REG7,
			clk => clk_REG7,
			clr => clr_REG7,
			ena => ena_REG7
		);
	REG8: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG8,
			outp => outp_REG8,
			clk => clk_REG8,
			clr => clr_REG8,
			ena => ena_REG8
		);
	REG9: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG9,
			outp => outp_REG9,
			clk => clk_REG9,
			clr => clr_REG9,
			ena => ena_REG9
		);
	REG10: REG
		GENERIC MAP(
			data_width => data_width
		)
		PORT MAP(
			inp => inp_REG10,
			outp => outp_REG10,
			clk => clk_REG10,
			clr => clr_REG10,
			ena => ena_REG10
		);

	sel_ALU0 <= T ( 0 TO 2 );
	sel_ALU1 <= T ( 3 TO 5 );
	sel_ALU2 <= T ( 6 TO 8 );
	sel_ALU3 <= T ( 9 TO 11 );
	clk_REG0 <= clk;
	clr_REG0 <= reset;
	ena_REG0 <= T(12);
	clk_REG1 <= clk;
	clr_REG1 <= reset;
	ena_REG1 <= T(13);
	clk_REG2 <= clk;
	clr_REG2 <= reset;
	ena_REG2 <= T(14);
	clk_REG3 <= clk;
	clr_REG3 <= reset;
	ena_REG3 <= T(15);
	clk_REG4 <= clk;
	clr_REG4 <= reset;
	ena_REG4 <= T(16);
	clk_REG5 <= clk;
	clr_REG5 <= reset;
	ena_REG5 <= T(17);
	clk_REG6 <= clk;
	clr_REG6 <= reset;
	ena_REG6 <= T(18);
	clk_REG7 <= clk;
	clr_REG7 <= reset;
	ena_REG7 <= T(19);
	clk_REG8 <= clk;
	clr_REG8 <= reset;
	ena_REG8 <= T(20);
	clk_REG9 <= clk;
	clr_REG9 <= reset;
	ena_REG9 <= T(21);
	clk_REG10 <= clk;
	clr_REG10 <= reset;
	ena_REG10 <= T(22);

	in_1_ALU0 <= outp_REG8
		when (T ( 23 TO 24 ) = "00") else outp_REG9
		when (T ( 23 TO 24 ) = "01") else outp_REG2
		when (T ( 23 TO 24 ) = "10") else outp_REG6;
	in_2_ALU0 <= outp_REG0
		when (T ( 25 TO 26 ) = "00") else outp_REG6
		when (T ( 25 TO 26 ) = "01") else outp_REG7;
	in_1_ALU1 <= outp_REG1
		when (T ( 27 TO 28 ) = "00") else outp_REG10
		when (T ( 27 TO 28 ) = "01") else outp_REG7;
	in_2_ALU1 <= outp_REG9
		when (T ( 29 TO 30 ) = "00") else outp_REG3
		when (T ( 29 TO 30 ) = "01") else outp_REG6;
	in_1_ALU2 <= outp_REG2
		when (T ( 31 TO 31 ) = "0") else outp_REG5;
	in_2_ALU2 <= outp_REG0
		when (T ( 32 TO 32 ) = "0") else outp_REG4;
	in_1_ALU3 <= outp_REG1
		when (T ( 33 TO 33 ) = "0") else outp_REG7;
	in_2_ALU3 <= outp_REG3
		when (T ( 34 TO 34 ) = "0") else outp_REG6;

	inp_REG0 <= a;
	inp_REG1 <= d;
	inp_REG2 <= b;
	inp_REG3 <= c;
	inp_REG4 <= outp_ALU1
		when (T ( 35 TO 35 ) = "0") else outp_ALU2;
	inp_REG5 <= outp_ALU3;
	inp_REG6 <= outp_ALU0;
	inp_REG7 <= outp_ALU1;
	inp_REG8 <= outp_ALU0;
	inp_REG9 <= outp_ALU0
		when (T ( 36 TO 36 ) = "0") else outp_ALU1;
	inp_REG10 <= outp_ALU2;

	output_0 <= outp_REG5;
	output_1 <= outp_REG8;
	output_2 <= outp_REG4;
END ARCHITECTURE;